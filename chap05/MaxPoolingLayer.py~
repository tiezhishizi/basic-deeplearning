#!/usr/bin/env python
# -*- coding:utf8 -*-
# Power by viekie. 2017-05-27 22:59:44
import numpy as np


class MaxPoolingLayer(object):
    def __init__(self, input_width, input_height, channel_number,
                 filter_width, filter_height, stride):
        self.input_width = input_width
        self.input_height = input_height
        self.channel_number = channel_number
        self.filter_width = filter_width
        self.filter_height = filter_height
        self.stride = stride
        self.output_widht = (input_width - filter_width) / stride + 1
        self.output_height = (input_height - filter_height) / stride + 1
        self.output_array = np.zeros((channel_number,
                                      self.output_height, self.output_widht))

    def forward(self, input_array):
        for d in range(self.channel_number):
            for i in range(self.output_height):
                for j in range(self.output_widht):
                    self.output_array[d][i][j] = \
                        (get_patch(input_array[d], i, j, self.filter_width,
                                   self.filter_width, self.stride).max())

    def backward(self, input_array, sensitivity_array):
        self.delta_array = np.zeros(input_array.shape)
        for d in range(self.channel_number):
            for i in range(self.output_height):
                for j in range(self.output_widht):
                    patch_array = \
                        get_patch(input_array[d], i, j, self.filter_width,
                                  self.filter_height, self.stride)
                    k, l = get_max_index(patch_array)
                    self.delta_array[d, i* self.stride + k,
                                     j * stride + l] = \
                        sensitivity_array[d, i, j]

    def get_patch(self, input_array, i, j, stride, height, width):
        '''
        获取需要被卷积的单元, 针对２Ｄ和３Ｄ分别进行获取
        '''
        ret_array = []
        nd = input_array.ndim
        if nd == 3:
            sd = input_array.shape[0]
            for d in range(sd):
                ret_array.append(self.get_sub_array(input_array[d], i, j,
                                                    stride, height, width))
        else:
            ret_array = self.get_sub_array(input_array,
                                           i, j, stride, height, width)
        return ret_array
